# FIAP - Faculdade de Inform√°tica e Administra√ß√£o Paulista

<p align="center">
<a href= "https://www.fiap.com.br/"><img src="assets/logo-fiap.png" alt="FIAP - Faculdade de Inform√°tica e Admnistra√ß√£o Paulista" border="0" width=40% height=40%></a>
</p>

<br>


# Projeto: fiap_fase3_cap1-novo

## Atividade em Grupo: FIAP - 1TIAOB - 2025/1 - Fase3 Cap1

## üë®‚Äçüéì Integrantes: 
- <a href="">Alice C. M. Assis - RM 566233</a>
- <a href="">Leonardo S. Souza - RM 563928</a>
- <a href="">Lucas B. Francelino - RM 561409</a> 
- <a href="">Pedro L. T. Silva - RM 561644</a> 
- <a href="">Vitor A. Bezerra - RM 563001</a>

## üë©‚Äçüè´ Professores:
### Tutor(a) 
- <a href="proflucas.moreira@fiap.com.br">Lucas Gomes Moreira</a>
### Coordenador(a)
- <a href="profandre.chiovato@fiap.com.br">Andr√© Godoi Chiovato</a>


## üìú Descri√ß√£o

Nesta etapa, a FarmTech Solutions implementa um sistema de irriga√ß√£o inteligente com sensores de umidade, nutrientes e pH, capazes de acionar automaticamente a bomba de irriga√ß√£o conforme os dados coletados. As informa√ß√µes s√£o armazenadas em um banco de dados SQL, permitindo visualiza√ß√£o e an√°lises estat√≠sticas dos resultados.

## Objetivos do projeto:

- Heran√ßa da Fase 3: Realizar um fork do projeto da Fase 3 [https://github.com/Hinten/fiap_fase3_cap1-novo](https://github.com/Hinten/fiap_fase3_cap1-novo) melhorias solicitadas no enunciado;
- C√≥digo C/C++ otimizado: Entregar um c√≥digo revisado e otimizado para o ESP32, gerenciando sensores e exibindo dados no display LCD;
- Banco de dados: Aprimorar o banco de dados, revisando e atualizando o modelo de neg√≥cio da FarmTech Solutions;
- C√≥digo Python com Scikit-learn e Streamlit: Implementar a modelagem preditiva utilizando Scikit-learn e uma interface interativa com Streamlit;
- Integra√ß√£o do Serial Plotter: Demonstrar o uso do Serial Plotter com prints do Wokwi para monitoramento das vari√°veis, insira e explicar os prints no README;
- Documenta√ß√£o e atualiza√ß√£o no GitHub: Atualizar o reposit√≥rio com documenta√ß√£o detalhada no README, incluindo explica√ß√µes das melhorias, imagens e prints;
- V√≠deo: Gravar um v√≠deo de at√© 5 minutos mostrando o funcionamento do sistema atualizado.

## Automa√ß√£o e intelig√™ncia na FarmTech Solutions

**Confira o v√≠deo de apresenta√ß√£o do projeto clicando no link ou imagem abaixo:**

<div align="center">
  <a href="https://youtu.be/XujLcoHgntE" target="_blank">
    <img src="assets/Banner FIAP_fase4_cap1.png" alt="Fase4Cap1" border="0" width="70%" height="70%"/>
  </a>
</div>


[https://youtu.be/XujLcoHgntE](https://youtu.be/XujLcoHgntE)

## Entrega 1: Sistema de Sensores e Controle com ESP32

### 1Ô∏è‚É£ Circuito de sensores

O circuito de sensores foi atualizado, com os seguintes componentes:

<p align="center"><img src="assets/sistema-de-Irrigacao.JPG" alt="Circuito de sensores" border="0" width=70% height=70%></p>

    - link do sistem no Wokwi: https://wokwi.com/projects/433871258996030465

Abaixo est√£o os componentes utilizados:
- 1x ESP32
- 1x Sensor LDR representando o Sensor de pH
- 1x Sensor de temperatura e umidade DHT22
- 1x Bot√£o representando o Sensor de F√≥sforo
- 1x Bot√£o representando o Sensor de Pot√°ssio
- 1x Rel√©
- 1x Led representando a bomba d'√°gua
- 1x Display LCD com 4 linhas, 20 caracteres por linha - lcd2004

### C√≥digo do ESP32

O c√≥digo do ESP32 foi atualizado, e pode ser encontrado no arquivo [sketch.cpp](src/wokwi/src/sketch.cpp). 
O c√≥digo √© respons√°vel por monitorar a necessidade de irriga√ß√£o em uma planta√ß√£o, simulando sensores de nutrientes e condi√ß√µes ambientais.
A vers√£o anterior pode ser encontrada no arquivo [sketch.ino](src/wokwi/old/sketch.ino). 
Segue abaixo a explica√ß√£o do c√≥digo atualizado e melhorias em rela√ß√£o a vers√£o anterior

## Funcionamento

O sistema de irriga√ß√£o inteligente passou por uma grande evolu√ß√£o na transi√ß√£o do c√≥digo `sketch.ino` para o novo `sketch.cpp`. Abaixo, destacamos as principais mudan√ßas e melhorias implementadas:

### Principais melhorias do `sketch.cpp` em rela√ß√£o ao `sketch.ino`

- **Estrutura e Organiza√ß√£o:**
  - O c√≥digo foi modularizado, com fun√ß√µes separadas para conex√£o Wi-Fi, envio de dados √† API, atualiza√ß√£o do display LCD e registro no Serial Monitor, facilitando manuten√ß√£o e expans√£o.
  - Uso de `constexpr` e tipos expl√≠citos para defini√ß√£o de pinos e constantes, aumentando a clareza e seguran√ßa.

- **Integra√ß√£o com Rede e API:**
  - O ESP32 conecta-se automaticamente ao Wi-Fi e envia dados dos sensores para uma API remota, que pode decidir sobre a irriga√ß√£o de forma centralizada e inteligente.
  - O sistema consulta a API para saber se deve irrigar, tornando a decis√£o mais robusta e baseada em dados externos.

- **L√≥gica de Decis√£o Otimizada:**
  - A l√≥gica local de ativa√ß√£o da irriga√ß√£o foi mantida, mas agora √© poss√≠vel priorizar a resposta da API, tornando o sistema h√≠brido (local + remoto).
  - O c√°lculo do pH simulado pelo LDR foi aprimorado: agora o valor √© convertido proporcionalmente para a escala real de pH (0 a 14), tornando a simula√ß√£o mais fiel.
  - A contagem de condi√ß√µes cr√≠ticas foi simplificada e otimizada, tornando o c√≥digo mais enxuto e eficiente.

- **Interface e Feedback ao Usu√°rio:**
  - Inclus√£o de display LCD I2C para exibir, em tempo real, umidade, pH, estado dos nutrientes e status da irriga√ß√£o.
  - Mensagens mais claras e resumidas no Serial Monitor, facilitando o acompanhamento e debug.

- **Robustez e Manuten√ß√£o:**
  - Fun√ß√µes auxiliares centralizam a atualiza√ß√£o das sa√≠das (LCD e Serial), facilitando futuras manuten√ß√µes.
  - O tratamento dos bot√µes foi refinado para evitar leituras falsas, com debounce otimizado e vari√°veis de estado bem definidas.

- **Identifica√ß√£o e Expans√£o:**
  - O ESP32 envia seu ID √∫nico para a API, permitindo rastreabilidade e controle individualizado dos sensores.
  - O c√≥digo est√° preparado para integra√ß√£o com novos sensores, atuadores e funcionalidades futuras.

#### Resumo das principais diferen√ßas

| Aspecto                  | Vers√£o Anterior (`sketch.ino`) | Vers√£o Atual (`sketch.cpp`)         |
|--------------------------|---------------------------------|-------------------------------------|
| Organiza√ß√£o              | C√≥digo monol√≠tico               | Modularizado, fun√ß√µes separadas     |
| Rede/API                 | N√£o possui                      | Integra√ß√£o Wi-Fi e API remota       |
| Display                  | N√£o possui                      | LCD I2C com dados em tempo real     |
| Decis√£o de irriga√ß√£o     | Apenas local                    | Local + consulta √† API              |
| Convers√£o de pH          | Simples (divis√£o por 100)       | Proporcional √† escala real (0-14)   |
| Robustez                 | B√°sica                          | Debounce otimizado, logs claros     |
| Expansibilidade          | Limitada                        | Estrutura pronta para expans√£o      |

Essas melhorias tornam o sistema mais inteligente, confi√°vel, f√°cil de manter e pronto para integra√ß√£o com solu√ß√µes de agricultura digital e IoT.

---


### Exemplos de Trechos do C√≥digo

- **Defini√ß√£o dos pinos dos sensores e atuadores (agora com constexpr e tipos expl√≠citos):**
  ```cpp
  constexpr uint8_t BUTTON_P      = 5;   // Bot√£o f√≥sforo (GPIO5)
  constexpr uint8_t BUTTON_K      = 4;   // Bot√£o pot√°ssio (GPIO4)
  constexpr uint8_t LDR_PIN       = 32;  // Pino LDR (GPIO32)
  constexpr uint8_t DHTPIN        = 12;
  constexpr uint8_t RELAY_PIN     = 25;
  constexpr uint8_t LED_PIN       = 2;
  constexpr uint8_t BUTTON_API    = 18;
  constexpr auto    DHTTYPE       = DHT22;
  ```

- **Leitura dos sensores e bot√µes (com debounce otimizado):**
  ```cpp
  uint8_t leituraAtual = digitalRead(BUTTON_P);
  if(leituraAtual == LOW && ultimoEstadoFosforo == HIGH) {
    estadoFosforo = !estadoFosforo;
    delay(150);  // Debounce reduzido
  }
  ultimoEstadoFosforo = leituraAtual;

  leituraAtual = digitalRead(BUTTON_K);
  if(leituraAtual == LOW && ultimoEstadoPotassio == HIGH) {
    estadoPotassio = !estadoPotassio;
    delay(150);
  }
  ultimoEstadoPotassio = leituraAtual;

  uint16_t ldrValue = analogRead(LDR_PIN);  // 0-4095
  float umidade = dht.readHumidity();
  float phSimulado = (ldrValue / 4095.0f) * 14.0f; // Convers√£o proporcional pH
  ```

- **L√≥gica de decis√£o para acionar a irriga√ß√£o (local + API):**
  ```cpp
  uint8_t condicoesCriticas = 0;
  condicoesCriticas += !estadoFosforo;
  condicoesCriticas += !estadoPotassio;
  condicoesCriticas += (ldrValue > 700);
  condicoesCriticas += (umidade < 60.0f);

  bool irrigacaoAtiva_local = condicoesCriticas >= 2;

  // Envio dos dados para API e consulta decis√£o remota
  int resposta_irrigacao = should_irrigate(doc);
  bool irrigacaoAtiva = irrigacaoAtiva_local;
  if (resposta_irrigacao != -1) {
    irrigacaoAtiva = resposta_irrigacao == 1;
  }

  digitalWrite(RELAY_PIN, irrigacaoAtiva);
  digitalWrite(LED_PIN, irrigacaoAtiva);
  ```

- **Atualiza√ß√£o do display LCD e log no Serial Monitor:**
  ```cpp
  void atualizarLCD(float& umidade, float& ph, bool& irrigStatus) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(F("U:"));
    lcd.print(umidade, 1);
    lcd.print(F("% pH:"));
    lcd.print(ph, 1);
    lcd.setCursor(0, 1);
    lcd.print(F("F:"));
    lcd.print(estadoFosforo ? F("Y") : F("N"));
    lcd.print(F(" K:"));
    lcd.print(estadoPotassio ? F("Y") : F("N"));
    lcd.print(F(" I:"));
    lcd.print(irrigStatus ? F("ON") : F("--"));
  }
  ```

- **Envio de dados para API e identifica√ß√£o do dispositivo:**
  ```cpp
  char chipidStr[17];
  void iniciar_sensor() {
    uint64_t chipid = ESP.getEfuseMac();
    sprintf(chipidStr, "%016llX", chipid);
    JsonDocument doc;
    doc["serial"] = chipidStr;
    post_data(doc, init_sensor);
  }
  ```
  
- **Exemplo de condi√ß√£o cr√≠tica:**
  - LDR (pH): `ldrValue > 7` (Foi aplicado um fator de √∑100 na sa√≠da do LDR, para simular o valor do pH que varia de 0 a 14)
  - Umidade: `umidade < 60`
  - F√≥sforo e Pot√°ssio: bot√µes desligados


- **Valores poss√≠veis para cada sensor:**
  - LDR (pH): `0 a 14` (condi√ß√£o: 0 a 7 = 1 positivo, 8 a 14 = 0 negativo)
  - Umidade: `de 0 a 100%` (condi√ß√£o: 0 a 59 = 0 negativo, 60 a 100 = 1 positivo)
  - Bot√£o (F√≥sforo): `0 ou 1` (condi√ß√£o: 0 negativo, 1 positivo)
  - Bot√£o (Pot√°ssio): `0 ou 1` (condi√ß√£o: 0 negativo, 1 positivo)
  - Rel√© (Irriga√ß√£o): `0 ou 1` (consi√ß√£o: 0 ligado, 1 desligado)
  - Bot√£o (API): `0 ou 1` (previs√£o: 0 n√£o vai chover, 1 vai chover)


- **Todas as condi√ß√µes poss√≠veis (API = 0):**
  - 01 - (F√≥sforo = 0 / Pot√°ssio = 0 / pH = 0 / Umidade = 0) = Ligar Irriga√ß√£o
  - 02 - (F√≥sforo = 0 / Pot√°ssio = 0 / pH = 0 / Umidade = 1) = Ligar Irriga√ß√£o
  - 03 - (F√≥sforo = 0 / Pot√°ssio = 0 / pH = 1 / Umidade = 0) = Ligar Irriga√ß√£o
  - 04 - (F√≥sforo = 0 / Pot√°ssio = 0 / pH = 1 / Umidade = 1) = Ligar Irriga√ß√£o
  - 05 - (F√≥sforo = 0 / Pot√°ssio = 1 / pH = 0 / Umidade = 0) = Ligar Irriga√ß√£o
  - 06 - (F√≥sforo = 0 / Pot√°ssio = 1 / pH = 0 / Umidade = 1) = Ligar Irriga√ß√£o
  - 07 - (F√≥sforo = 0 / Pot√°ssio = 1 / pH = 1 / Umidade = 0) = Ligar Irriga√ß√£o
  - 08 - (F√≥sforo = 0 / Pot√°ssio = 1 / pH = 1 / Umidade = 1) = Desligar Irriga√ß√£o
  - 09 - (F√≥sforo = 1 / Pot√°ssio = 0 / pH = 0 / Umidade = 0) = Ligar Irriga√ß√£o
  - 10 - (F√≥sforo = 1 / Pot√°ssio = 0 / pH = 0 / Umidade = 1) = Ligar Irriga√ß√£o
  - 11 - (F√≥sforo = 1 / Pot√°ssio = 0 / pH = 1 / Umidade = 0) = Ligar Irriga√ß√£o
  - 12 - (F√≥sforo = 1 / Pot√°ssio = 0 / pH = 1 / Umidade = 1) = Desligar Irriga√ß√£o
  - 13 - (F√≥sforo = 1 / Pot√°ssio = 1 / pH = 0 / Umidade = 0) = Ligar Irriga√ß√£o
  - 14 - (F√≥sforo = 1 / Pot√°ssio = 1 / pH = 0 / Umidade = 1) = Desligar Irriga√ß√£o
  - 15 - (F√≥sforo = 1 / Pot√°ssio = 1 / pH = 1 / Umidade = 0) = Desligar Irriga√ß√£o
  - 16 - (F√≥sforo = 1 / Pot√°ssio = 1 / pH = 1 / Umidade = 1) = Desligar Irriga√ß√£o

### Demonstra√ß√£o dos resultados do circuito:

* Todos o sensores do circuito apresentando resultados <u>positivos</u>:
<p align="center"><img src="assets/irrigacao_condicao_positiva.png" alt="Circuito de sensores" border="0" width=70% height=70%></p>

* Todos os sensores do circuito apresentando resultados <u>negativos</u>:
<p align="center"><img src="assets/irrigacao_condicao_negativa.png" alt="Circuito de sensores" border="0" width=70% height=70%></p>


## Conex√£o com o wifi e envio de dados para a API

Para que a simula√ß√£o funcione corretamente, √© necess√°rio configurar a conex√£o com Wi-Fi simulado do Wokwi em como, configurar o IP do servidor local da API.
No momento, neste MVP a api e a simula√ß√£o do ESP32 est√£o rodando localmente. 
Para a confirgura√ß√£o funcionar corretamente, √© necess√°rio alterar o arquivo [platformio.ini](src/wokwi/platformio.ini) e setar a v√°riavel 'API_URL' para 'http://**IP DE SUA M√ÅQUINA NA REDE LOCAL**:8180' conforme exemplo abaixo:

```plaintext
[env:esp32]
platform = espressif32
framework = arduino
board = esp32dev
lib_deps = 
    bblanchon/ArduinoJson@^7.4.1
    marcoschwartz/LiquidCrystal_I2C@^1.1.4
    adafruit/DHT sensor library@^1.4.4
build_flags = 
    '-D API_URL="http://192.168.0.62:8180"'
    '-D NETWORK_SSID="Wokwi-GUEST"'
    '-D NETWORK_PASSWORD=""'
```

>NOTA1: N√£o sete o ip da API para localhost ou 127.0.0.1 pois o ESP32 n√£o conseguir√° se conectar a ele, pois o localhost do ESP32 √© o pr√≥prio ESP32 e n√£o a m√°quina onde o servidor est√° rodando.

>NOTA2: Caso voc√™ esteja rodando a simula√ß√£o e mesmo assim o ESP32 n√£o consiga se conectar a API, verifique se o firewall da sua m√°quina est√° bloqueando a porta 8180, caso esteja, libere a porta para que o ESP32 consiga se conectar.


Ap√≥s configurado o arquivo `platformio.ini`, voc√™ poder√° iniciar a simula√ß√£o do ESP32 no Wokwi. O circuito ir√° coletar os dados dos sensores e envi√°-los para a API, que por sua vez ir√° armazenar os dados no banco de dados.

## API para salvar os dados do sensor

Neste Projeto, foi implementada uma API b√°sica utilizando o FastAPI para receber os dados do sensor e armazen√°-los no banco de dados. A API permite que o ESP32 envie as leituras dos sensores, que s√£o ent√£o salvas no banco de dados para posterior an√°lise e visualiza√ß√£o.
Para facilitar os testes, a API est√° configurada para rodar localmente na porta 8180 e ser√° iniciada automaticamente junto ao dashboard ao executar o comando `streamlit run main_dash.py` quando a vari√°vel de ambiente `ENABLE_API` for setada como `true`.
No entanto, caso queira, a api pode ser executada separadamente executando o arquivo [api_basica.py](src/wokwi_api/api_basica.py).

A api tamb√©m funciona como ponte de comunica√ß√£o entre o sensor e o modelo preditivo criado pelo grupo no aprimoramento da l√≥gica de irriga√ß√£o.

Explica√ß√µes mais detalhadas sobre como iniciar o dashboard e vari√°veis de ambiente ser√£o apresentadas na se√ß√£o "INSTALANDO E EXECUTANDO O PROJETO", a seguir neste mesmo README.md.


## Funcionamento da API "init_sensor"

  # Funcionamento:
    Recebe uma Requisi√ß√£o
    A requisi√ß√£o deve conter um campo serial no corpo JSON, representando o n√∫mero de s√©rie √∫nico do sensor.

  # Verifica e Cria Tipos de Sensores
    Para cada valor do TipoSensorEnum, o script verifica se j√° existe um tipo correspondente no banco de dados.
    Se o tipo ainda n√£o existir, ele √© criado e persistido.

  # Verifica Exist√™ncia de Sensor
    Antes de cadastrar um novo sensor, o script verifica se j√° existe um sensor com o mesmo n√∫mero de s√©rie (serial) e o mesmo tipo.
    Se j√° existir, o sensor n√£o √© recriado (evita duplicatas).

  # Cria√ß√£o do Sensor
    Caso o sensor ainda n√£o exista, ele √© criado com:
      Nome no formato Sensor <tipo> - <serial>
      Serial fornecido pela requisi√ß√£o
      Tipo de sensor associado
      Descri√ß√£o padr√£o

  # Resposta da API
    Ao final do processo, retorna um JSON com status de sucesso e uma mensagem confirmando o cadastro.

  # Exemplo requisi√ß√£o:
    POST /init
    {
      "serial": "ABC123"
    }

  # Exemplo de resposta:
    {
      "status": "success",
      "message": "Sensor cadastrado com sucesso."
    }


## Funcionamento da API "receber_leitura"

### Funcionamento Geral
A API "receber_leitura" recebe leituras dos sensores do ESP32 e armazena os dados no banco de dados, associando cada leitura ao tipo correto de sensor (umidade, pH, pot√°ssio, f√≥sforo, rel√©/irriga√ß√£o) conforme o modelo de dados atualizado.

### Fluxo da Requisi√ß√£o
- **M√©todo:** POST
- **Endpoint:** `/leitura/`
- **Corpo esperado (JSON):**
  - `serial`: n√∫mero de s√©rie do sensor (obrigat√≥rio)
  - `umidade`: valor da leitura do sensor de umidade (opcional)
  - `ph`: valor da leitura do sensor de pH (opcional)
  - `estado_potassio`: estado do sensor de pot√°ssio (opcional)
  - `estado_fosforo`: estado do sensor de f√≥sforo (opcional)
  - `estado_irrigacao`: estado do rel√©/irriga√ß√£o (opcional)

### L√≥gica de Processamento
1. **Busca de Sensores:**
   - A API busca todos os sensores cadastrados no banco de dados com o serial informado.
   - Se nenhum sensor for encontrado, retorna erro informando que o sensor n√£o foi localizado.

2. **Identifica√ß√£o do Tipo de Sensor:**
   - Para cada sensor encontrado, identifica o tipo (UMIDADE, PH, POTASSIO, FOSFORO, RELE).
   - Para cada tipo, verifica se o campo correspondente est√° presente na requisi√ß√£o:
     - Se sim, cria uma nova leitura para aquele sensor, com o valor informado e a data/hora atual.
     - Se n√£o, ignora aquele sensor/tipo.

3. **Armazenamento:**
   - As leituras v√°lidas s√£o salvas no banco de dados na tabela `LEITURA_SENSOR`.

4. **Resposta:**
   - Ap√≥s o processamento, retorna um JSON indicando sucesso ou erro.

### Exemplo de Requisi√ß√£o POST
```json
{
  "serial": "ABC123",
  "umidade": 55.2,
  "ph": 6.8,
  "estado_potassio": 1,
  "estado_fosforo": 0,
  "estado_irrigacao": 1
}
```

### Exemplo de Resposta
```json
{
  "status": "success",
  "message": "Leitura recebida com sucesso"
}
```

### Observa√ß√µes
- O endpoint aceita m√∫ltiplos tipos de leitura em uma √∫nica requisi√ß√£o, salvando cada valor no sensor correspondente.
- Caso o tipo de sensor n√£o seja encontrado para o serial informado, retorna erro espec√≠fico.
- O campo `estado_irrigacao` representa o estado do rel√© (0 = desligado, 1 = ligado).
- Todos os dados s√£o registrados com timestamp do momento do recebimento.

## Funcionamento da API "irrigacao"

### Funcionamento Geral
A API "irrigacao" √© respons√°vel por prever, de forma inteligente, se a irriga√ß√£o deve ser ativada ou n√£o, considerando tanto os dados dos sensores locais quanto informa√ß√µes meteorol√≥gicas externas.

### Fluxo da Requisi√ß√£o
- **M√©todo:** POST
- **Endpoint:** `/irrigacao/`
- **Corpo esperado (JSON):**
  - `serial`: n√∫mero de s√©rie do sensor (obrigat√≥rio)
  - `umidade`: valor da leitura do sensor de umidade (opcional)
  - `ph`: valor da leitura do sensor de pH (opcional)
  - `estado_potassio`: estado do sensor de pot√°ssio (opcional)
  - `estado_fosforo`: estado do sensor de f√≥sforo (opcional)

### L√≥gica de Processamento
1. **Identifica√ß√£o do Plantio e Localiza√ß√£o:**
   - A API busca o(s) sensor(es) pelo serial informado e identifica o plantio e a propriedade associados.
   - Caso a propriedade possua cidade cadastrada, utiliza essa cidade para buscar a previs√£o do tempo.
   - Se n√£o houver cidade cadastrada, utiliza uma cidade padr√£o (ex: "S√£o Paulo").

2. **Obten√ß√£o de Dados Clim√°ticos:**
   - A API consulta um servi√ßo externo para obter a previs√£o do tempo da cidade identificada.
   - Se j√° houver uma previs√£o recente (menos de 24h), reutiliza os dados para otimizar chamadas.

3. **Decis√£o de Irriga√ß√£o:**
   - Se a previs√£o indicar chuva, a irriga√ß√£o √© automaticamente desativada (`irrigar: false`).
   - Caso contr√°rio, a decis√£o √© feita por um modelo preditivo, que considera os dados dos sensores (umidade, pH, f√≥sforo, pot√°ssio) e a hora da leitura.
   - O modelo retorna se deve irrigar ou n√£o.

4. **Resposta:**
   - A API retorna um JSON indicando se a irriga√ß√£o deve ser ativada (`irrigar: true`) ou n√£o (`irrigar: false`).
   - Em caso de erro (ex: sensor n√£o encontrado), retorna mensagem de erro.

### Exemplo de Requisi√ß√£o POST
```json
{
  "serial": "ABC123",
  "umidade": 55.2,
  "ph": 6.8,
  "estado_potassio": 1,
  "estado_fosforo": 0
}
```

### Exemplo de Resposta
```json
{
  "status": "success",
  "irrigar": true
}
```

### Observa√ß√µes
- A decis√£o de irriga√ß√£o √© feita de forma h√≠brida: primeiro verifica a previs√£o de chuva, depois utiliza o modelo preditivo.
- O endpoint pode ser utilizado pelo ESP32 para decidir automaticamente se deve acionar a bomba de irriga√ß√£o.
- O modelo preditivo pode ser ajustado conforme a necessidade, utilizando dados hist√≥ricos e vari√°veis relevantes.
- Caso o sensor n√£o seja encontrado, a API retorna erro espec√≠fico.

---

### 2Ô∏è‚É£ Demonstra√ß√£o do Serial Plotter

Para monitorar o comportamento do circuito e acompanhar o resultado dos sensores demonstramos abaixo alguns cen√°rios.

### SERIAL PLOTTER

Foram criadas algumas condi√ß√µes apresentadas na leitura dos sensores de pH e Umidade, como: Oscila√ß√£o Est√°vel, Oscila√ß√£o Var√≠vel, Varia√ß√£o para cima e Varia√ß√£o para Baixo. (Obs: Comparamos apenas pH e Umidade, pors s√£o os √∫nicos sensores dos nosso circuito que n√£o oscilavam apenas entre 0 e 1):
* Azul = Umidade
* Rosa = pH

<br>
* <strong>Oscila√ß√£o Est√°vel:</strong> Pouca varia√ß√£o de umidade e pouca varia√ß√£o de pH.
<p align="center">
  <b>Gr√°fico</b><br>
  <img src="assets/wokwi/estavel_grafico.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>

<p align="center">
  <b>Dados</b><br>
  <img src="assets/wokwi/estavel_dados.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>


<br>
* <strong>Oscila√ß√£o Vari√°vel:</strong> Muita varia√ß√£o de umidade que influencia em uma grande varia√ß√£o de pH.
<p align="center">
  <b>Gr√°fico</b><br>
  <img src="assets/wokwi/oscilacao_grafico.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>

<p align="center">
  <b>Dados</b><br>
  <img src="assets/wokwi/oscilacao_dados.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>


<br>
* <strong>Varia√ß√£o para Cima:</strong> O aumento da umidade influenciou no aumento do pH.
<p align="center">
  <b>Gr√°fico</b><br>
  <img src="assets/wokwi/variacao_cima_grafico.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>

<p align="center">
  <b>Dados</b><br>
  <img src="assets/wokwi/variacao_cima_dados.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>

<br>
* <strong>Varia√ß√£o para Baixo:</strong> O queda da umidade influenciou na redu√ß√£o do pH.
<p align="center">
  <b>Gr√°fico</b><br>
  <img src="assets/wokwi/variacao_baixo_grafico.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>

<p align="center">
  <b>Dados</b><br>
  <img src="assets/wokwi/variacao_baixo_dados.png" alt="Serial Plotter" border="0" width=70% height=70%>
</p>

---

### 3Ô∏è‚É£ Armazenamento de Dados em Banco SQL com Python

O armazenamento dos dados coletados pelos sensores foi implementado em Python, utilizando um banco de dados SQL. O c√≥digo √© respons√°vel por criar tabelas, inserir dados e realizar opera√ß√µes CRUD (Criar, Ler, Atualizar e Deletar) no banco de dados.

### MER

O grupo realizou pequenas mudan√ßas no modelo de banco de dados em rela√ß√£o √† entrega anterior. O modelo abaixo representa as tabelas e relacionamentos atuais utilizados para o armazenamento dos dados:

<p align="center">
  <b>Novo</b><br>
  <img src="assets/mer.png" alt="MER" border="0" width=70% height=70%>
</p>


Novo Modelo de Entidade-Relacionamento:

Tabela: CULTURA
  - id (INTEGER NOT NULL) [PK]
  - nome (VARCHAR(255) NOT NULL)
  - observacao (TEXT(1000))

Tabela: PROPRIEDADE
  - id (INTEGER NOT NULL) [PK]
  - nome (VARCHAR(100) NOT NULL)
  - cnpj (VARCHAR(14))
  - cidade (VARCHAR(255))

Tabela: CAMPO
  - id (INTEGER NOT NULL) [PK]
  - propriedade_id (INTEGER NOT NULL) [FK -> PROPRIEDADE]
  - identificador (VARCHAR(100) NOT NULL)
  - area_ha (FLOAT NOT NULL)

Tabela: PLANTIO
  - id (INTEGER NOT NULL) [PK]
  - nome (VARCHAR(100) NOT NULL)
  - campo_id (INTEGER NOT NULL) [FK -> CAMPO]
  - tipo_cultura (INTEGER NOT NULL) [FK -> CULTURA]
  - data_inicio (DATETIME NOT NULL)
  - data_fim (DATETIME)
  - observacao (TEXT(1000))

Tabela: UNIDADE
  - id (INTEGER NOT NULL) [PK]
  - nome (VARCHAR(50) NOT NULL)
  - multiplicador (FLOAT NOT NULL)

Tabela: TIPO_SENSOR
  - id (INTEGER NOT NULL) [PK]
  - nome (VARCHAR(255) NOT NULL)
  - tipo (VARCHAR(15) NOT NULL)

Tabela: SENSOR
  - id (INTEGER NOT NULL) [PK]
  - cod_serial (VARCHAR(255))
  - tipo_sensor_id (INTEGER NOT NULL) [FK -> TIPO_SENSOR]
  - plantio_id (INTEGER) [FK -> PLANTIO]
  - nome (VARCHAR(255) NOT NULL)
  - descricao (VARCHAR(255))
  - data_instalacao (DATETIME)
  - unidade_id (INTEGER) [FK -> UNIDADE]
  - latitude (FLOAT)
  - longitude (FLOAT)

Tabela: LEITURA_SENSOR
  - id (INTEGER NOT NULL) [PK]
  - sensor_id (INTEGER NOT NULL) [FK -> SENSOR]
  - data_leitura (DATETIME NOT NULL)
  - valor (FLOAT NOT NULL)

Tabela: IRRIGACAO
  - id (INTEGER NOT NULL) [PK]
  - quantidade_total (FLOAT NOT NULL)
  - data_hora (DATETIME NOT NULL)
  - observacao (TEXT(1000))
  - sensor_id (INTEGER NOT NULL) [FK -> SENSOR]

Tabela: NUTRIENTE
  - id (INTEGER NOT NULL) [PK]
  - nome (VARCHAR(255) NOT NULL)
  - observacao (TEXT(1000))

Tabela: APLICACAO_NUTRIENTE
  - id (INTEGER NOT NULL) [PK]
  - plantio_id (INTEGER NOT NULL) [FK -> PLANTIO]
  - nutriente_id (INTEGER NOT NULL) [FK -> NUTRIENTE]
  - unidade_id (INTEGER NOT NULL) [FK -> UNIDADE]
  - data_aplicacao (DATETIME NOT NULL)
  - quantidade (FLOAT NOT NULL)
  - observacao (TEXT(1000))

### Principais altera√ß√µes realizadas

- Atualiza√ß√£o da lista de tabelas e colunas, incluindo campos como cidade em PROPRIEDADE, cod_serial em SENSOR, e ajustes em chaves estrangeiras.

### JUSTIFICATIVA DA ESCOLHA DA ESTRUTURA DE DADOS

A estrutura de dados foi projetada para atender √†s necessidades de um sistema de gerenciamento agr√≠cola, garantindo flexibilidade, escalabilidade e consist√™ncia. Abaixo est√£o os principais pontos que justificam as escolhas realizadas:

1. **Normaliza√ß√£o e Organiza√ß√£o**:
   - O modelo segue os princ√≠pios de normaliza√ß√£o para evitar redund√¢ncia de dados e garantir integridade referencial.
   - As tabelas foram organizadas de forma a refletir entidades reais do dom√≠nio agr√≠cola, como `PLANTIO`, `CAMPO`, `SENSOR` e `NUTRIENTE`.

2. **Flexibilidade**:
   - A inclus√£o de tabelas como `UNIDADE` e `TIPO_SENSOR` permite a adi√ß√£o de novos tipos de sensores ou unidades de medida sem a necessidade de altera√ß√µes estruturais significativas.
   - A tabela `OBSERVACAO` em v√°rias entidades permite armazenar informa√ß√µes adicionais sem comprometer a estrutura principal.

3. **Escalabilidade**:
   - O uso de tipos de dados como `FLOAT` e `CLOB` garante que o sistema possa lidar com grandes volumes de dados e informa√ß√µes detalhadas.
   - A separa√ß√£o de tabelas como `LEITURA_SENSOR` e `APLICACAO_NUTRIENTE` permite o registro de eventos hist√≥ricos, facilitando an√°lises futuras.

4. **Padroniza√ß√£o**:
   - Os nomes das tabelas e colunas foram padronizados em mai√∫sculas para facilitar a leitura e manter consist√™ncia.
   - Tipos de dados foram escolhidos com base nas melhores pr√°ticas para bancos de dados Oracle, como o uso de `DATE` para datas e `VARCHAR2` para strings.

5. **Relacionamentos Claros**:
   - A utiliza√ß√£o de chaves estrangeiras garante a integridade dos dados e define claramente os relacionamentos entre as entidades.
   - Por exemplo, a tabela `PLANTIO` referencia `CAMPO` e `CULTURA`, enquanto `SENSOR` referencia `TIPO_SENSOR` e `PLANTIO`.

6. **Adapta√ß√£o √†s Necessidades do Dom√≠nio**:
   - A estrutura foi adaptada para refletir as opera√ß√µes agr√≠colas, como o registro de leituras de sensores, aplica√ß√µes de nutrientes e irriga√ß√£o.
   - A inclus√£o de colunas como `latitude` e `longitude` em `SENSOR` permite a localiza√ß√£o geogr√°fica precisa, essencial para an√°lises espaciais.

Essa estrutura foi escolhida para garantir que o sistema seja robusto, f√°cil de manter e capaz de atender √†s demandas de um ambiente agr√≠cola em constante evolu√ß√£o.

## Models e Python

Para realizar a convers√£o das linhas e colunas da database para Python, foram definidas classes as quais s√£o respons√°veis por fazer as opera√ß√µes CRUD e demais funcionalidades do banco de dados.
Essas classes podem ser encontradas na pasta `src/database/models`, e todas elas herdam a classe principal chamada [Model](src/database/tipos_base/model.py)


### EXECUTAR O SISTEMA E REALIZAR OPERA√á√ïES CRUD

O sistema foi desenvolvido em Python e utiliza um banco de dados Oracle para armazenar os dados. O c√≥digo √© modularizado, permitindo f√°cil manuten√ß√£o e expans√£o.

## üì¶ Requisitos
- Python 3.13.2
  - Bibliotecas:
```plaintext
  oracledb==3.1.0
  pandas==2.2.3
  matplotlib==3.10.1
  streamlit==1.44.1
  SQLAlchemy==2.0.40
  fastapi==0.115.12
  pydantic==2.11.5
  uvicorn==0.34.3
  dotenv==0.9.9
  seaborn==0.13.2
  plotly==6.1.2
  joblib==1.5.1
  scikit-learn==1.7.0
```

## üîó Instala√ß√£o
- Para instalar as depend√™ncias, utilize o seguinte comando:
    ```bash
    pip install -r requirements.txt
    ```
  
- Para executar o c√≥digo, utilize o seguinte comando:
    ```bash
    streamlit run main_dash.py
    ```
    > **Nota:** O c√≥digo foi desenvolvido para rodar em ambiente local, utilizando o Streamlit.


## Arquivo de Configura√ß√£o

O projeto utiliza um arquivo especial denominado **`.env`** para armazenar vari√°veis de ambiente sens√≠veis, como credenciais de banco de dados e chaves de APIs externas. Por raz√µes de seguran√ßa, esse arquivo **n√£o deve ser compartilhado publicamente**.

### üîë Vari√°veis Utilizadas

| Vari√°vel      | Descri√ß√£o                                                                                                | Exemplo de Valor                  |
|---------------|----------------------------------------------------------------------------------------------------------|-----------------------------------|
| SQL_LITE      | Define o banco de dados a ser usado (`true` ou `false`)                                                  | `true` ou `false`                 |
| LOGGING_ENABLED      | Define se o logger da aplica√ß√£o ser√° ativado (`true` ou `false`)                                         | `true` ou `false`                 |
| ENABLE_API      | Define se a API que salva os dados do sensor ser√° ativada juntamente com o dashboard (`true` ou `false`) | `true` ou `false`                 |


### ‚öôÔ∏è Exemplo de arquivo `.env`

```plaintext
SQL_LITE=true
LOGGING_ENABLED=true
ENABLE_API=true
```

- Se `SQL_LITE=true`, o sistema usar√° o banco SQLite local.
- Se `SQL_LITE=false`, ser√° utilizado o banco Oracle da FIAP (o sistema apresentar√° uma tela de login para colocar o usu√°rio e senha do banco de dados).

## Login

Ao executar o sistema, se foi setado o SQL_LITE como `false`, primeiramente voc√™ ver√° uma tela de login para inserir o usu√°rio e senha do banco de dados Oracle da FIAP. Ap√≥s o login, voc√™ ter√° acesso ao dashboard, onde poder√° visualizar os dados coletados pelos sensores, gerar posts informativos e monitorar as condi√ß√µes ambientais em tempo real.

<p align="center">
  <img src="assets/dashboard/login.PNG" alt="login" border="0" width=40% height=40%>
</p>

- DSN: `oracle.fiap.com.br:1521/ORCL`
- Usu√°rio: `seu usuario no banco de dados da FIAP`
- Senha: `sua senha no banco de dados da FIAP`

- Ap√≥s o login, o usu√°rio ser√° direcionado para a tela inicial do sistema.

## Realizando opera√ß√µes CRUD
- O sistema permite realizar opera√ß√µes CRUD (Criar, Ler, Atualizar e Deletar) em todas as tabelas do banco de dados.
- As opera√ß√µes s√£o realizadas atrav√©s de formul√°rios, onde o usu√°rio pode inserir os dados necess√°rios.
- Ap√≥s a inser√ß√£o dos dados, o sistema ir√° validar as informa√ß√µes e realizar a opera√ß√£o no banco de dados.
- O sistema tamb√©m permite visualizar os dados cadastrados, editar e excluir registros.
- As opera√ß√µes s√£o realizadas atrav√©s de menus, onde o usu√°rio pode selecionar a opera√ß√£o desejada.

## Leitura de dados (READ)

Para realizar uma opera√ß√£o de leitura, basta o us√°rio selecionar um dos modelos dispon√≠veis no menu principal. O sistema ir√° exibir os dados cadastrados na tabela selecionada.

<p align="center">
  <img src="assets/dashboard/read.PNG" alt="leitura" border="0" width=80% height=80%>
</p>

üí° Exemplo de consulta SQL para opera√ß√£o READ:
```sql
SELECT "PROPRIEDADE".id, "PROPRIEDADE".nome, "PROPRIEDADE".cnpj
FROM "PROPRIEDADE" ORDER BY "PROPRIEDADE".id
```

## Cria√ß√£o de dados (CREATE)
Para realizar uma opera√ß√£o de cria√ß√£o, basta o us√°rio selecionar um dos modelos dispon√≠veis no menu principal e clicar no bot√£o "Novo". 
O sistema ir√° exibir um formul√°rio para o usu√°rio preencher os dados necess√°rios. Esse formul√°rio ir√° variar de acordo com o modelo selecionado.
O sistema ir√° validar os dados e realizar a opera√ß√£o no banco de dados.

<p align="center">
  <img src="assets/dashboard/create/botao_novo.PNG" alt="cria√ß√£o" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/dashboard/create/botao_salvar.PNG" alt="cria√ß√£o" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/dashboard/create/registro_salvo.PNG" alt="cria√ß√£o" border="0" width=80% height=80%>
</p>

üí° Exemplo de opera√ß√£o CREATE:
```sql
INSERT INTO "PROPRIEDADE" (id, nome, cnpj) VALUES ("PROPRIEDADE_SEQ_ID".nextval, 'Nova Propriedade', NULL) RETURNING "PROPRIEDADE".id INTO :ret_0
```

## Atualiza√ß√£o de dados (UPDATE)
Para realizar uma opera√ß√£o de atualiza√ß√£o, basta o us√°rio selecionar um dos modelos dispon√≠veis no menu principal, selecionar uma das linhas e clicar no bot√£o "Editar".
O sistema ir√° exibir um formul√°rio com os dados cadastrados. O usu√°rio pode alterar os dados e clicar no bot√£o "Salvar" para atualizar o registro no banco de dados.

<p align="center">
  <img src="assets/dashboard/update/botao_editar.PNG" alt="atualiza√ß√£o" border="0" width=80% height=80%>
<p>

<p align="center">
  <img src="assets/dashboard/update/botao_salvar_editar.PNG" alt="atualiza√ß√£o" border="0" width=80% height=80%>
<p>

<p align="center">
  <img src="assets/dashboard/update/registro_atualizado.PNG" alt="atualiza√ß√£o" border="0" width=80% height=80%>
</p>


üí° Exemplo de opera√ß√£o UPDATE:
```sql
 UPDATE "PROPRIEDADE" SET nome='Update propriedade' WHERE "PROPRIEDADE".id = 3
```


## Exclus√£o de dados (DELETE)
Para realizar uma opera√ß√£o de exclus√£o, basta o us√°rio selecionar um dos modelos dispon√≠veis no menu principal, selecionar uma das linhas e clicar no bot√£o "Editar" e posteriormente "Excluir".

<p align="center">
  <img src="assets/dashboard/delete/botao_editar.PNG" alt="atualiza√ß√£o" border="0" width=80% height=80%>
<p>

<p align="center">
  <img src="assets/dashboard/delete/botao_excluir.PNG" alt="atualiza√ß√£o" border="0" width=80% height=80%>
<p>

<p align="center">
  <img src="assets/dashboard/delete/registro_excluido.PNG" alt="atualiza√ß√£o" border="0" width=80% height=80%>
</p>

üí° Exemplo de opera√ß√£o DELETE:
```sql
DELETE FROM "PROPRIEDADE" WHERE "PROPRIEDADE".id = 3
```

## Importar Tabelas com os dados

As tabelas com os dados utilizados no sistema podem ser encontradas na pasta em `assets/database_export.zip`.

O arquivo zip cont√©m os arquivos no formato CSV, que podem ser importados para o banco de dados utilizando o dashboard, conforme passos abaixo.

> **Nota:** Os dados das leituras do sensor est√£o datados de **15/05/2025** at√© **20/05/2025**.

1. O usu√°rio deve selecionar a op√ß√£o "Importar Banco de Dados" no menu principal.
<p align="center">
  <img src="assets/dashboard/importar_banco_de_dados/importar_banco_de_dados.PNG" alt="importar_db" border="0" width=80% height=80%>
</p>

2. Selecione o arquivo ZIP localizado em `assets/database_export.zip`, espere carregar, role a p√°gina at√© o final e clique no bot√£o "Salvar no Banco de Dados".
<p align="center">
  <img src="assets/dashboard/importar_banco_de_dados/salvar_no_banco_de_dados.PNG" alt="salvar_db" border="0" width=80% height=80%>
</p>

3. N√£o feche a janela e espere a opera√ß√£o ser conclu√≠da. Ap√≥s a conclus√£o, o sistema ir√° exibir uma mensagem de sucesso. Caso ocorra algum erro, tente novamente.

<p align="center">
  <img src="assets/dashboard/importar_banco_de_dados/importacao_concluida.PNG" alt="salvar_db" border="0" width=80% height=80%>
</p>

# Dashboard em Python para Visualiza√ß√£o dos Dados

O projeto inclui um dashboard desenvolvido em Python, utilizando a biblioteca Streamlit, que permite visualizar os dados armazenados no banco de dados de forma interativa e amig√°vel. O dashboard apresenta gr√°ficos e tabelas que facilitam a an√°lise dos dados coletados pelos sensores.

## Atualiza√ß√µes de registro no Dashboard

Conforme solicitado no enunciado, o dashboard permite realizar atualiza√ß√µes de registro diretamente na interface. O usu√°rio pode selecionar um registro, editar os dados e salvar as altera√ß√µes, que ser√£o refletidas no banco de dados.

Para atualizar a leitura de um sensor, o usario dever√° selecionar a op√ß√£o "Leituras de Sensores" no menu principal. Em seguida, o usu√°rio pode clicar no bot√£o "Editar" para modificar os dados de uma leitura espec√≠fica.
Ap√≥s realizar as altera√ß√µes, o usu√°rio deve clicar no bot√£o "Salvar" para atualizar o registro no banco de dados, conforme mencionado nas opera√ß√µes CRUD.

<p align="center">
  <img src="assets/dashboard/atualizacao_leitura.PNG" alt="atualiza√ß√£o_leitura" border="0" width=80% height=80%>
</p>

## Visualiza√ß√£o de gr√°ficos reais ou simulados

O dashboard tamb√©m inclui gr√°ficos que representam os dados coletados pelos sensores. Esses gr√°ficos podem ser gerados a partir de dados reais ou simulados, dependendo da op√ß√£o selecionada.

Para visualizar os gr√°ficos o usu√°rio deve selecionar uma das op√ß√µes de "Gr√°ficos" no menu principal. 
A seguir, o usario dever√° selecionar o sensor ou sensores desejados, data inicial e data final.
Posteriormente, o usu√°rio deve clicar no bot√£o "Gerar Simula√ß√£o" para visualizar dados simulados ou "Gerar Gr√°fico" para visualizar dados reais.

<p align="center">
  <img src="assets/dashboard/grafico1.PNG" alt="graficos" border="0" width=80% height=80%>
</p>
<p align="center">
  <img src="assets/dashboard/grafico2.PNG" alt="graficos" border="0" width=80% height=80%>
</p>

## Poss√≠veis Erros que podem ocorrer durante a execu√ß√£o do sistema

- **Erro de Conex√£o com o Banco de Dados [WinError 10054]**: Caso ocorra este erro, a solu√ß√£o √© clicar em outra op√ß√£o do menu para que o sistema reinicie a conex√£o com o banco de dados.
<p align="center">
  <img src="assets/dashboard/erro_conexao.JPG" alt="WinError 10054" border="0" width=80% height=80%>
</p>

# Incorpora√ß√£o do Scikit-learn

O grupo realizou treinamento de modelos preditivos para aprimorar a l√≥gica de irriga√ß√£o.

O arquivo de treinamento do modelo pode ser encontrado em [treinamento_modelos.ipynb](src/modelo_preditivo/treinamento_modelos.ipynb)

## Explora√ß√£o de Dados

No dashboard foi disponibilizada uma view com informa√ß√µes b√°sicas para a explora√ß√£o de dados do dataset de treinamento do modelo, conforme imagens abaixo:

<p align="center">
  <img src="assets/dashboard/modelo_preditivo/exploracao_dados_1.JPG" alt=exploracao_dados_1" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/dashboard/modelo_preditivo/exploracao_dados_2.JPG" alt="exploracao_dados_2" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/dashboard/modelo_preditivo/exploracao_dados_3.JPG" alt="exploracao_dados_3" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/dashboard/modelo_preditivo/exploracao_dados_4.JPG" alt="exploracao_dados_4" border="0" width=80% height=80%>
</p>

## Previs√£o Manual de Irriga√ß√£o

O dashboard tamb√©m permite que o usu√°rio fa√ßa previs√µes manuais de irriga√ß√£o, inseririndo os valores de umidade, pH, pot√°ssio e f√≥sforo, e o sistema ir√° calcular se a irriga√ß√£o deve ser ativada ou n√£o, conforme pode ser verificado no print abaixo:


<p align="center">
  <img src="assets/dashboard/modelo_preditivo/previsao_manual.JPG" alt="previsao_manual" border="0" width=80% height=80%>
</p>

## Previs√£o autom√°tica e integra√ß√£o com o ESP32

Conforme citado anteriormente, o projeto foi estruturado para permitir a integra√ß√£o com o ESP32, possibilitando que o dispositivo envie leituras de sensores e receba decis√µes de irriga√ß√£o.

Esta previs√£o autom√°tica √© realizada atrav√©s de uma API que recebe os dados dos sensores e utiliza um modelo preditivo treinado para decidir se a irriga√ß√£o deve ser ativada ou n√£o, conforme pode ser verificado no arquivo [prever_irrigacao.py](src/wokwi_api/prever_irrigacao.py)

# Integra√ß√£o Python com API P√∫blica

Para acessar a api o usu√°rio dever√° selecionar as op√ß√µes "Previs√£o do Tempo" ou "Irriga√ß√£o" no menu principal.

<p align="center">
  <img src="assets/api_metereologica/api_metereologica.JPG" alt="apimetereologica" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/api_metereologica/previsao_do_tempo.JPG" alt="previsaodotempo" border="0" width=80% height=80%>
</p>

<p align="center">
  <img src="assets/api_metereologica/logica_irrigacao.JPG" alt="previsaodotempo" border="0" width=80% height=80%>
</p>


## Funcionamento API

#  1. Objetivo
  Fornecer dados meteorol√≥gicos para auxiliar na decis√£o de irriga√ß√£o autom√°tica, integrando-se com sensores locais e o sistema de controle.

# 2. Endpoints Principais

  GET /previsao?cidade={cidade}
  Retorna:
  {
    "temperatura": 25.5,
    "umidade_ar": 65,
    "chuva": false,
    "condicao": "Ensolarado"
  }

# 3. Par√¢metros de Decis√£o

  A API considera:
  Umidade do solo (<30% = irrigar)
  Previs√£o de chuva (se true = n√£o irrigar)
  pH do solo (5.5 a 7.0 = ideal)

# 4. Fluxo T√≠pico

  Sistema envia cidade do plantio
  API retorna condi√ß√µes clim√°ticas
  L√≥gica local combina com dados de sensores
  Toma decis√£o de irriga√ß√£o

# 5. Exemplo de Uso

  python
  dados = obter_dados_clima("Campinas")
  if not dados["chuva"] and umidade_solo < 30:
      acionar_irrigacao()

# 6. Requisitos
  Chave API v√°lida
  Conex√£o internet
  Formato cidade: "Cidade,UF" (opcional)

# 7. Seguran√ßa
  Limite: 60 chamadas/minuto
  Dados criptografados em tr√¢nsito

## 8. C√≥digos de Erro

  401: Chave inv√°lida
  404: Cidade n√£o encontrada
  429: Limite excedido

## üìÅ Estrutura de pastas

Dentre os arquivos e pastas presentes na raiz do projeto, definem-se:

- <b>.streamlit</b>: Pasta que cont√©m arquivos de configura√ß√£o do Streamlit, como o tema e a barra lateral.
- <b>assets</b>: Aqui est√£o os arquivos relacionados a elementos n√£o-estruturados deste reposit√≥rio, como imagens.
- <b>src</b>: Todo o c√≥digo fonte criado para o desenvolvimento do projeto ao longo de todas as fases.
  - <b>dashboard</b>: C√≥digo do dashboard desenvolvido em Python, utilizando a biblioteca Streamlit. ([dashboard](src/dashboard/))
  - <b>database</b>: Execu√ß√£o dos comandos de banco de dados, como Conectar, Cadastrar, Listar, Editar e Excluir.
  - <b>logger</b>: C√≥digo respons√°vel por registrar as opera√ß√µes realizadas no banco de dados, como inser√ß√µes, atualiza√ß√µes e exclus√µes.
  - <b>service</b>: Conex√£o com a api p√∫blica de previs√£o do tempo, respons√°vel por coletar dados meteorol√≥gicos.
  - <b>wokwi</b>: C√≥digo do ESP32, respons√°vel por monitorar a necessidade de irriga√ß√£o em uma planta√ß√£o, simulando sensores de nutrientes e condi√ß√µes ambientais.
- <b>README</b>: arquivo que serve como guia e explica√ß√£o geral sobre o projeto (o mesmo que voc√™ est√° lendo agora).
- <b>main_dash</b>: arquivo principal do dashboard, onde o c√≥digo √© executado. Ele foi colocado nesta localiza√ß√£o para evitar problemas com imports

## üóÉ Hist√≥rico de lan√ßamentos

* 0.1.2 - 20/05/2025  - Atualiza√ß√µes finais no readme e corre√ß√£o de bugs
* 0.1.1 - 18/05/2025  - Atualiza√ß√µes do readme, melhorias no c√≥digo e corre√ß√£o de bugs
* 0.1.0 - 16/05/2025  - Vers√£o preliminar da nossa aplica√ß√£o

## üìã Licen√ßa

<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><a property="dct:title" rel="cc:attributionURL" href="https://github.com/agodoi/template">MODELO GIT FIAP</a> por <a rel="cc:attributionURL dct:creator" property="cc:attributionName" href="https://fiap.com.br">Fiap</a> est√° licenciado sobre <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">Attribution 4.0 International</a>.</p>
